# 트랜잭션 격리 수준
트랜잭션 격리 수준(Isolation Level)이란, 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.  
크게 READ UNCOMMITED, READ COMMITED, REPEATABLE COMMIT, SERIALIZABLE이 있다.  

## READ UNCOMMITED
READ UNCOMMITED 격리 수준에서는 각 트랜잭션의 변경내용이 COMMIT되지 않아도 다른 트랜잭션에서 식별 가능하다.  
A레코드가 들어있는 트랜잭션이 변경을 일으키고 COMMIT되기 전에 다른 트랜잭션에서 변경 여부를 식별 가능하다.  
이러한 경우 트랜잭션이 비정상적으로 종료되어 ROLLBACK 되어도 다른 트랜잭션에서 조회하여 사용한다면 심각한 동시성 문제가 발생 가능하다.  
이런 상황은 A트랜잭션에서 커밋되지 않은 데이터가 보이는 상황을 Dirty Read라고 한다.

## READ COMMITED
READ COMMITED는 위의 UNCOMMITED와 다르게 COMMIT된 데이터만 볼 수 있다. 그렇기 때문에 Dirty Read현상은 발생하지 않는다.  
A트랜잭션에서 작업중인 레코드를 B트랜잭션에서 접근하려하는데 이미 A트랜잭션 내부적으로 데이터가 변경되어있으면 B트랜잭션은 변경된 데이터가 아니라 이전의 데이터를 조회하게 된다.
변경하려하는 데이터 즉, 원래의 데이터는 메인 데이터에 위치되어있고 언두로그에는 업데이트 하려하는 데이터가 존재하여 트랜잭션이 종료될 때 업데이트된다.
실제 커밋할 때 메인 데이터가 정해지고 메인데이터가 정해지면 언두 로그는 지워진다.  
하지만 이런 경우 A트랜잭션에서 같은 조회쿼리를 날렸을 때, 외부에서 데이터를 저장한다면 Phantom Read현상이 나타난다.
1번 조회쿼리와 2번조회 쿼리가 정확히 일치하지만, 1번과 2번의 조회 결과가 다르게 나올 수 있다. 외부에서 테이블에 데이터를 추가할 수 있기 때문이다.

## REPEATABLE READ
REPEATABLE READ는 MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. 바이너리 로그를 가진 MySQL 서버에서는 최소 격리 수준으로 REPEATABLE READ를 사용하도록 설정되어 있다.  
이 격리수준은 READ COMMITED에서 발생하는 NON-REPEATABLE READ가 발생하지 않는다.  
READ COMMITED와 다른점은 언두로그의 차이다. READ COMMITED는 트랜잭션이 데이터에 접근할 때, 언두로그가 가리키는 커밋된 데이터가 변경되면 조회한 데이터도 변경된다.  
REPEATABLE READ는 언두로그가 변경되어도 READ COMMITED와 다르게 트랜잭션 시작시에 언두로그에서 변하지 않는다.  
트랜잭션이 시작되면 본인 트랜잭션의 작업 이외의 모든것의 변화가 멈추기 때문에 데이터 정합성 문제가 일어나지 않는다.

## SERIALIZABLE
가장 단순한 격리 수준이면서 가장 엄격한 격리 수준이다. 그만큼 동시 처리 수준도 다른 격리 수준에 비해 매우 낮다.  
InnoDB에서는 기본적으로 SELECT를 하게되면 아무런 레코드 잠금을 하지 않고 실행된다. 하지만 격리수준을 SERIALIZABLE로 높이면 모든 SELECT및 모든 쿼리가 이전에 락을 획득한 작업이 종료될 때 까지 기다려야 한다.  
안전하지만 동시에 매우 느린 격리 수준으로 잘 사용하지 않는다.
